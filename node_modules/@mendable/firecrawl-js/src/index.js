"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrawlWatcher = exports.FirecrawlError = void 0;
var axios_1 = require("axios");
var zt = require("zod");
var zod_to_json_schema_1 = require("zod-to-json-schema");
var isows_1 = require("isows");
var typescript_event_target_1 = require("typescript-event-target");
;
;
/**
 * Custom error class for Firecrawl.
 * Extends the built-in Error class to include a status code.
 */
var FirecrawlError = /** @class */ (function (_super) {
    __extends(FirecrawlError, _super);
    function FirecrawlError(message, statusCode) {
        var _this = _super.call(this, message) || this;
        _this.statusCode = statusCode;
        return _this;
    }
    return FirecrawlError;
}(Error));
exports.FirecrawlError = FirecrawlError;
/**
 * Main class for interacting with the Firecrawl API.
 * Provides methods for scraping, searching, crawling, and mapping web content.
 */
var FirecrawlApp = /** @class */ (function () {
    /**
     * Initializes a new instance of the FirecrawlApp class.
     * @param config - Configuration options for the FirecrawlApp instance.
     */
    function FirecrawlApp(_a) {
        var _b = _a.apiKey, apiKey = _b === void 0 ? null : _b, _c = _a.apiUrl, apiUrl = _c === void 0 ? null : _c;
        var baseUrl = apiUrl || "https://api.firecrawl.dev";
        if (this.isCloudService(baseUrl) && typeof apiKey !== "string") {
            throw new FirecrawlError("No API key provided", 401);
        }
        this.apiKey = apiKey || '';
        this.apiUrl = baseUrl;
    }
    FirecrawlApp.prototype.isCloudService = function (url) {
        return url.includes('api.firecrawl.dev');
    };
    /**
     * Scrapes a URL using the Firecrawl API.
     * @param url - The URL to scrape.
     * @param params - Additional parameters for the scrape request.
     * @returns The response from the scrape operation.
     */
    FirecrawlApp.prototype.scrapeUrl = function (url, params) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, jsonData, schema, response, responseData, error_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        headers = {
                            "Content-Type": "application/json",
                            Authorization: "Bearer ".concat(this.apiKey),
                        };
                        jsonData = __assign({ url: url }, params);
                        if ((_a = jsonData === null || jsonData === void 0 ? void 0 : jsonData.extract) === null || _a === void 0 ? void 0 : _a.schema) {
                            schema = jsonData.extract.schema;
                            // Try parsing the schema as a Zod schema
                            try {
                                schema = (0, zod_to_json_schema_1.zodToJsonSchema)(schema);
                            }
                            catch (error) {
                            }
                            jsonData = __assign(__assign({}, jsonData), { extract: __assign(__assign({}, jsonData.extract), { schema: schema }) });
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, axios_1.default.post(this.apiUrl + "/v1/scrape", jsonData, { headers: headers })];
                    case 2:
                        response = _b.sent();
                        if (response.status === 200) {
                            responseData = response.data;
                            if (responseData.success) {
                                return [2 /*return*/, __assign({ success: true, warning: responseData.warning, error: responseData.error }, responseData.data)];
                            }
                            else {
                                throw new FirecrawlError("Failed to scrape URL. Error: ".concat(responseData.error), response.status);
                            }
                        }
                        else {
                            this.handleError(response, "scrape URL");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _b.sent();
                        this.handleError(error_1.response, "scrape URL");
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    /**
     * Searches using the Firecrawl API and optionally scrapes the results.
     * @param query - The search query string.
     * @param params - Optional parameters for the search request.
     * @returns The response from the search operation.
     */
    FirecrawlApp.prototype.search = function (query, params) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, jsonData, schema, response, responseData, error_2;
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            return __generator(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        headers = {
                            "Content-Type": "application/json",
                            Authorization: "Bearer ".concat(this.apiKey),
                        };
                        jsonData = {
                            query: query,
                            limit: (_a = params === null || params === void 0 ? void 0 : params.limit) !== null && _a !== void 0 ? _a : 5,
                            tbs: params === null || params === void 0 ? void 0 : params.tbs,
                            filter: params === null || params === void 0 ? void 0 : params.filter,
                            lang: (_b = params === null || params === void 0 ? void 0 : params.lang) !== null && _b !== void 0 ? _b : "en",
                            country: (_c = params === null || params === void 0 ? void 0 : params.country) !== null && _c !== void 0 ? _c : "us",
                            location: params === null || params === void 0 ? void 0 : params.location,
                            origin: (_d = params === null || params === void 0 ? void 0 : params.origin) !== null && _d !== void 0 ? _d : "api",
                            timeout: (_e = params === null || params === void 0 ? void 0 : params.timeout) !== null && _e !== void 0 ? _e : 60000,
                            scrapeOptions: (_f = params === null || params === void 0 ? void 0 : params.scrapeOptions) !== null && _f !== void 0 ? _f : { formats: [] },
                        };
                        if ((_h = (_g = jsonData === null || jsonData === void 0 ? void 0 : jsonData.scrapeOptions) === null || _g === void 0 ? void 0 : _g.extract) === null || _h === void 0 ? void 0 : _h.schema) {
                            schema = jsonData.scrapeOptions.extract.schema;
                            // Try parsing the schema as a Zod schema
                            try {
                                schema = (0, zod_to_json_schema_1.zodToJsonSchema)(schema);
                            }
                            catch (error) {
                            }
                            jsonData = __assign(__assign({}, jsonData), { scrapeOptions: __assign(__assign({}, jsonData.scrapeOptions), { extract: __assign(__assign({}, jsonData.scrapeOptions.extract), { schema: schema }) }) });
                        }
                        _l.label = 1;
                    case 1:
                        _l.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.postRequest(this.apiUrl + "/v1/search", jsonData, headers)];
                    case 2:
                        response = _l.sent();
                        if (response.status === 200) {
                            responseData = response.data;
                            if (responseData.success) {
                                return [2 /*return*/, {
                                        success: true,
                                        data: responseData.data,
                                        warning: responseData.warning,
                                    }];
                            }
                            else {
                                throw new FirecrawlError("Failed to search. Error: ".concat(responseData.error), response.status);
                            }
                        }
                        else {
                            this.handleError(response, "search");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _l.sent();
                        if ((_k = (_j = error_2.response) === null || _j === void 0 ? void 0 : _j.data) === null || _k === void 0 ? void 0 : _k.error) {
                            throw new FirecrawlError("Request failed with status code ".concat(error_2.response.status, ". Error: ").concat(error_2.response.data.error, " ").concat(error_2.response.data.details ? " - ".concat(JSON.stringify(error_2.response.data.details)) : ''), error_2.response.status);
                        }
                        else {
                            throw new FirecrawlError(error_2.message, 500);
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, { success: false, error: "Internal server error.", data: [] }];
                }
            });
        });
    };
    /**
     * Initiates a crawl job for a URL using the Firecrawl API.
     * @param url - The URL to crawl.
     * @param params - Additional parameters for the crawl request.
     * @param pollInterval - Time in seconds for job status checks.
     * @param idempotencyKey - Optional idempotency key for the request.
     * @returns The response from the crawl operation.
     */
    FirecrawlApp.prototype.crawlUrl = function (url_1, params_1) {
        return __awaiter(this, arguments, void 0, function (url, params, pollInterval, idempotencyKey) {
            var headers, jsonData, response, id, error_3;
            var _a, _b;
            if (pollInterval === void 0) { pollInterval = 2; }
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        headers = this.prepareHeaders(idempotencyKey);
                        jsonData = __assign({ url: url }, params);
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.postRequest(this.apiUrl + "/v1/crawl", jsonData, headers)];
                    case 2:
                        response = _c.sent();
                        if (response.status === 200) {
                            id = response.data.id;
                            return [2 /*return*/, this.monitorJobStatus(id, headers, pollInterval)];
                        }
                        else {
                            this.handleError(response, "start crawl job");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_3 = _c.sent();
                        if ((_b = (_a = error_3.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) {
                            throw new FirecrawlError("Request failed with status code ".concat(error_3.response.status, ". Error: ").concat(error_3.response.data.error, " ").concat(error_3.response.data.details ? " - ".concat(JSON.stringify(error_3.response.data.details)) : ''), error_3.response.status);
                        }
                        else {
                            throw new FirecrawlError(error_3.message, 500);
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    FirecrawlApp.prototype.asyncCrawlUrl = function (url, params, idempotencyKey) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, jsonData, response, error_4;
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        headers = this.prepareHeaders(idempotencyKey);
                        jsonData = __assign({ url: url }, params);
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.postRequest(this.apiUrl + "/v1/crawl", jsonData, headers)];
                    case 2:
                        response = _c.sent();
                        if (response.status === 200) {
                            return [2 /*return*/, response.data];
                        }
                        else {
                            this.handleError(response, "start crawl job");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_4 = _c.sent();
                        if ((_b = (_a = error_4.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) {
                            throw new FirecrawlError("Request failed with status code ".concat(error_4.response.status, ". Error: ").concat(error_4.response.data.error, " ").concat(error_4.response.data.details ? " - ".concat(JSON.stringify(error_4.response.data.details)) : ''), error_4.response.status);
                        }
                        else {
                            throw new FirecrawlError(error_4.message, 500);
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    /**
     * Checks the status of a crawl job using the Firecrawl API.
     * @param id - The ID of the crawl operation.
     * @param getAllData - Paginate through all the pages of documents, returning the full list of all documents. (default: `false`)
     * @returns The response containing the job status.
     */
    FirecrawlApp.prototype.checkCrawlStatus = function (id_1) {
        return __awaiter(this, arguments, void 0, function (id, getAllData) {
            var headers, response, allData, statusData, data, resp, error_5;
            if (getAllData === void 0) { getAllData = false; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!id) {
                            throw new FirecrawlError("No crawl ID provided", 400);
                        }
                        headers = this.prepareHeaders();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 9, , 10]);
                        return [4 /*yield*/, this.getRequest("".concat(this.apiUrl, "/v1/crawl/").concat(id), headers)];
                    case 2:
                        response = _a.sent();
                        if (!(response.status === 200)) return [3 /*break*/, 7];
                        allData = response.data.data;
                        if (!(getAllData && response.data.status === "completed")) return [3 /*break*/, 6];
                        statusData = response.data;
                        if (!("data" in statusData)) return [3 /*break*/, 6];
                        data = statusData.data;
                        _a.label = 3;
                    case 3:
                        if (!(typeof statusData === 'object' && 'next' in statusData)) return [3 /*break*/, 5];
                        if (data.length === 0) {
                            return [3 /*break*/, 5];
                        }
                        return [4 /*yield*/, this.getRequest(statusData.next, headers)];
                    case 4:
                        statusData = (_a.sent()).data;
                        data = data.concat(statusData.data);
                        return [3 /*break*/, 3];
                    case 5:
                        allData = data;
                        _a.label = 6;
                    case 6:
                        resp = {
                            success: response.data.success,
                            status: response.data.status,
                            total: response.data.total,
                            completed: response.data.completed,
                            creditsUsed: response.data.creditsUsed,
                            expiresAt: new Date(response.data.expiresAt),
                            data: allData
                        };
                        if (!response.data.success && response.data.error) {
                            resp = __assign(__assign({}, resp), { success: false, error: response.data.error });
                        }
                        if (response.data.next) {
                            resp.next = response.data.next;
                        }
                        return [2 /*return*/, resp];
                    case 7:
                        this.handleError(response, "check crawl status");
                        _a.label = 8;
                    case 8: return [3 /*break*/, 10];
                    case 9:
                        error_5 = _a.sent();
                        throw new FirecrawlError(error_5.message, 500);
                    case 10: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    /**
     * Cancels a crawl job using the Firecrawl API.
     * @param id - The ID of the crawl operation.
     * @returns The response from the cancel crawl operation.
     */
    FirecrawlApp.prototype.cancelCrawl = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, response, error_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = this.prepareHeaders();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.deleteRequest("".concat(this.apiUrl, "/v1/crawl/").concat(id), headers)];
                    case 2:
                        response = _a.sent();
                        if (response.status === 200) {
                            return [2 /*return*/, response.data];
                        }
                        else {
                            this.handleError(response, "cancel crawl job");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_6 = _a.sent();
                        throw new FirecrawlError(error_6.message, 500);
                    case 4: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    /**
     * Initiates a crawl job and returns a CrawlWatcher to monitor the job via WebSocket.
     * @param url - The URL to crawl.
     * @param params - Additional parameters for the crawl request.
     * @param idempotencyKey - Optional idempotency key for the request.
     * @returns A CrawlWatcher instance to monitor the crawl job.
     */
    FirecrawlApp.prototype.crawlUrlAndWatch = function (url, params, idempotencyKey) {
        return __awaiter(this, void 0, void 0, function () {
            var crawl, id;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.asyncCrawlUrl(url, params, idempotencyKey)];
                    case 1:
                        crawl = _a.sent();
                        if (crawl.success && crawl.id) {
                            id = crawl.id;
                            return [2 /*return*/, new CrawlWatcher(id, this)];
                        }
                        throw new FirecrawlError("Crawl job failed to start", 400);
                }
            });
        });
    };
    /**
     * Maps a URL using the Firecrawl API.
     * @param url - The URL to map.
     * @param params - Additional parameters for the map request.
     * @returns The response from the map operation.
     */
    FirecrawlApp.prototype.mapUrl = function (url, params) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, jsonData, response, error_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = this.prepareHeaders();
                        jsonData = __assign({ url: url }, params);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.postRequest(this.apiUrl + "/v1/map", jsonData, headers)];
                    case 2:
                        response = _a.sent();
                        if (response.status === 200) {
                            return [2 /*return*/, response.data];
                        }
                        else {
                            this.handleError(response, "map");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_7 = _a.sent();
                        throw new FirecrawlError(error_7.message, 500);
                    case 4: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    /**
     * Initiates a batch scrape job for multiple URLs using the Firecrawl API.
     * @param url - The URLs to scrape.
     * @param params - Additional parameters for the scrape request.
     * @param pollInterval - Time in seconds for job status checks.
     * @param idempotencyKey - Optional idempotency key for the request.
     * @param webhook - Optional webhook for the batch scrape.
     * @returns The response from the crawl operation.
     */
    FirecrawlApp.prototype.batchScrapeUrls = function (urls_1, params_1) {
        return __awaiter(this, arguments, void 0, function (urls, params, pollInterval, idempotencyKey, webhook, ignoreInvalidURLs) {
            var headers, jsonData, schema, response, id, error_8;
            var _a, _b, _c;
            if (pollInterval === void 0) { pollInterval = 2; }
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        headers = this.prepareHeaders(idempotencyKey);
                        jsonData = __assign({ urls: urls, webhook: webhook, ignoreInvalidURLs: ignoreInvalidURLs }, params);
                        if ((_a = jsonData === null || jsonData === void 0 ? void 0 : jsonData.extract) === null || _a === void 0 ? void 0 : _a.schema) {
                            schema = jsonData.extract.schema;
                            // Try parsing the schema as a Zod schema
                            try {
                                schema = (0, zod_to_json_schema_1.zodToJsonSchema)(schema);
                            }
                            catch (error) {
                            }
                            jsonData = __assign(__assign({}, jsonData), { extract: __assign(__assign({}, jsonData.extract), { schema: schema }) });
                        }
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.postRequest(this.apiUrl + "/v1/batch/scrape", jsonData, headers)];
                    case 2:
                        response = _d.sent();
                        if (response.status === 200) {
                            id = response.data.id;
                            return [2 /*return*/, this.monitorJobStatus(id, headers, pollInterval)];
                        }
                        else {
                            this.handleError(response, "start batch scrape job");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_8 = _d.sent();
                        if ((_c = (_b = error_8.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.error) {
                            throw new FirecrawlError("Request failed with status code ".concat(error_8.response.status, ". Error: ").concat(error_8.response.data.error, " ").concat(error_8.response.data.details ? " - ".concat(JSON.stringify(error_8.response.data.details)) : ''), error_8.response.status);
                        }
                        else {
                            throw new FirecrawlError(error_8.message, 500);
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    FirecrawlApp.prototype.asyncBatchScrapeUrls = function (urls, params, idempotencyKey, webhook, ignoreInvalidURLs) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, jsonData, response, error_9;
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        headers = this.prepareHeaders(idempotencyKey);
                        jsonData = __assign({ urls: urls, webhook: webhook, ignoreInvalidURLs: ignoreInvalidURLs }, (params !== null && params !== void 0 ? params : {}));
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.postRequest(this.apiUrl + "/v1/batch/scrape", jsonData, headers)];
                    case 2:
                        response = _c.sent();
                        if (response.status === 200) {
                            return [2 /*return*/, response.data];
                        }
                        else {
                            this.handleError(response, "start batch scrape job");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_9 = _c.sent();
                        if ((_b = (_a = error_9.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) {
                            throw new FirecrawlError("Request failed with status code ".concat(error_9.response.status, ". Error: ").concat(error_9.response.data.error, " ").concat(error_9.response.data.details ? " - ".concat(JSON.stringify(error_9.response.data.details)) : ''), error_9.response.status);
                        }
                        else {
                            throw new FirecrawlError(error_9.message, 500);
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    /**
     * Initiates a batch scrape job and returns a CrawlWatcher to monitor the job via WebSocket.
     * @param urls - The URL to scrape.
     * @param params - Additional parameters for the scrape request.
     * @param idempotencyKey - Optional idempotency key for the request.
     * @returns A CrawlWatcher instance to monitor the crawl job.
     */
    FirecrawlApp.prototype.batchScrapeUrlsAndWatch = function (urls, params, idempotencyKey, webhook, ignoreInvalidURLs) {
        return __awaiter(this, void 0, void 0, function () {
            var crawl, id;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.asyncBatchScrapeUrls(urls, params, idempotencyKey, webhook, ignoreInvalidURLs)];
                    case 1:
                        crawl = _a.sent();
                        if (crawl.success && crawl.id) {
                            id = crawl.id;
                            return [2 /*return*/, new CrawlWatcher(id, this)];
                        }
                        throw new FirecrawlError("Batch scrape job failed to start", 400);
                }
            });
        });
    };
    /**
     * Checks the status of a batch scrape job using the Firecrawl API.
     * @param id - The ID of the batch scrape operation.
     * @param getAllData - Paginate through all the pages of documents, returning the full list of all documents. (default: `false`)
     * @returns The response containing the job status.
     */
    FirecrawlApp.prototype.checkBatchScrapeStatus = function (id_1) {
        return __awaiter(this, arguments, void 0, function (id, getAllData) {
            var headers, response, allData, statusData, data, resp, error_10;
            if (getAllData === void 0) { getAllData = false; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!id) {
                            throw new FirecrawlError("No batch scrape ID provided", 400);
                        }
                        headers = this.prepareHeaders();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 9, , 10]);
                        return [4 /*yield*/, this.getRequest("".concat(this.apiUrl, "/v1/batch/scrape/").concat(id), headers)];
                    case 2:
                        response = _a.sent();
                        if (!(response.status === 200)) return [3 /*break*/, 7];
                        allData = response.data.data;
                        if (!(getAllData && response.data.status === "completed")) return [3 /*break*/, 6];
                        statusData = response.data;
                        if (!("data" in statusData)) return [3 /*break*/, 6];
                        data = statusData.data;
                        _a.label = 3;
                    case 3:
                        if (!(typeof statusData === 'object' && 'next' in statusData)) return [3 /*break*/, 5];
                        if (data.length === 0) {
                            return [3 /*break*/, 5];
                        }
                        return [4 /*yield*/, this.getRequest(statusData.next, headers)];
                    case 4:
                        statusData = (_a.sent()).data;
                        data = data.concat(statusData.data);
                        return [3 /*break*/, 3];
                    case 5:
                        allData = data;
                        _a.label = 6;
                    case 6:
                        resp = {
                            success: response.data.success,
                            status: response.data.status,
                            total: response.data.total,
                            completed: response.data.completed,
                            creditsUsed: response.data.creditsUsed,
                            expiresAt: new Date(response.data.expiresAt),
                            data: allData
                        };
                        if (!response.data.success && response.data.error) {
                            resp = __assign(__assign({}, resp), { success: false, error: response.data.error });
                        }
                        if (response.data.next) {
                            resp.next = response.data.next;
                        }
                        return [2 /*return*/, resp];
                    case 7:
                        this.handleError(response, "check batch scrape status");
                        _a.label = 8;
                    case 8: return [3 /*break*/, 10];
                    case 9:
                        error_10 = _a.sent();
                        throw new FirecrawlError(error_10.message, 500);
                    case 10: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    /**
     * Extracts information from URLs using the Firecrawl API.
     * Currently in Beta. Expect breaking changes on future minor versions.
     * @param url - The URL to extract information from.
     * @param params - Additional parameters for the extract request.
     * @returns The response from the extract operation.
     */
    FirecrawlApp.prototype.extract = function (urls, params) {
        return __awaiter(this, void 0, void 0, function () {
            var headers, jsonData, jsonSchema, response, jobId, extractStatus, statusResponse, error_11;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        headers = this.prepareHeaders();
                        jsonData = __assign({ urls: urls }, params);
                        try {
                            if (!(params === null || params === void 0 ? void 0 : params.schema)) {
                                jsonSchema = undefined;
                            }
                            else if (params.schema instanceof zt.ZodType) {
                                jsonSchema = (0, zod_to_json_schema_1.zodToJsonSchema)(params.schema);
                            }
                            else {
                                jsonSchema = params.schema;
                            }
                        }
                        catch (error) {
                            throw new FirecrawlError("Invalid schema. Schema must be either a valid Zod schema or JSON schema object.", 400);
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 10, , 11]);
                        return [4 /*yield*/, this.postRequest(this.apiUrl + "/v1/extract", __assign(__assign({}, jsonData), { schema: jsonSchema }), headers)];
                    case 2:
                        response = _a.sent();
                        if (!(response.status === 200)) return [3 /*break*/, 8];
                        jobId = response.data.id;
                        extractStatus = void 0;
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.getRequest("".concat(this.apiUrl, "/v1/extract/").concat(jobId), headers)];
                    case 4:
                        statusResponse = _a.sent();
                        extractStatus = statusResponse.data;
                        if (extractStatus.status === "completed") {
                            if (extractStatus.success) {
                                return [2 /*return*/, {
                                        success: true,
                                        data: extractStatus.data,
                                        warning: extractStatus.warning,
                                        error: extractStatus.error
                                    }];
                            }
                            else {
                                throw new FirecrawlError("Failed to extract data. Error: ".concat(extractStatus.error), statusResponse.status);
                            }
                        }
                        else if (extractStatus.status === "failed" || extractStatus.status === "cancelled") {
                            throw new FirecrawlError("Extract job ".concat(extractStatus.status, ". Error: ").concat(extractStatus.error), statusResponse.status);
                        }
                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 1000); })];
                    case 5:
                        _a.sent(); // Polling interval
                        _a.label = 6;
                    case 6:
                        if (extractStatus.status !== "completed") return [3 /*break*/, 3];
                        _a.label = 7;
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        this.handleError(response, "extract");
                        _a.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        error_11 = _a.sent();
                        throw new FirecrawlError(error_11.message, 500);
                    case 11: return [2 /*return*/, { success: false, error: "Internal server error." }];
                }
            });
        });
    };
    /**
     * Prepares the headers for an API request.
     * @param idempotencyKey - Optional key to ensure idempotency.
     * @returns The prepared headers.
     */
    FirecrawlApp.prototype.prepareHeaders = function (idempotencyKey) {
        return __assign({ "Content-Type": "application/json", Authorization: "Bearer ".concat(this.apiKey) }, (idempotencyKey ? { "x-idempotency-key": idempotencyKey } : {}));
    };
    /**
     * Sends a POST request to the specified URL.
     * @param url - The URL to send the request to.
     * @param data - The data to send in the request.
     * @param headers - The headers for the request.
     * @returns The response from the POST request.
     */
    FirecrawlApp.prototype.postRequest = function (url, data, headers) {
        return axios_1.default.post(url, data, { headers: headers });
    };
    /**
     * Sends a GET request to the specified URL.
     * @param url - The URL to send the request to.
     * @param headers - The headers for the request.
     * @returns The response from the GET request.
     */
    FirecrawlApp.prototype.getRequest = function (url, headers) {
        return __awaiter(this, void 0, void 0, function () {
            var error_12;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, axios_1.default.get(url, { headers: headers })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        error_12 = _a.sent();
                        if (error_12 instanceof axios_1.AxiosError && error_12.response) {
                            return [2 /*return*/, error_12.response];
                        }
                        else {
                            throw error_12;
                        }
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sends a DELETE request to the specified URL.
     * @param url - The URL to send the request to.
     * @param headers - The headers for the request.
     * @returns The response from the DELETE request.
     */
    FirecrawlApp.prototype.deleteRequest = function (url, headers) {
        return __awaiter(this, void 0, void 0, function () {
            var error_13;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, axios_1.default.delete(url, { headers: headers })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        error_13 = _a.sent();
                        if (error_13 instanceof axios_1.AxiosError && error_13.response) {
                            return [2 /*return*/, error_13.response];
                        }
                        else {
                            throw error_13;
                        }
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Monitors the status of a crawl job until completion or failure.
     * @param id - The ID of the crawl operation.
     * @param headers - The headers for the request.
     * @param checkInterval - Interval in seconds for job status checks.
     * @param checkUrl - Optional URL to check the status (used for v1 API)
     * @returns The final job status or data.
     */
    FirecrawlApp.prototype.monitorJobStatus = function (id, headers, checkInterval) {
        return __awaiter(this, void 0, void 0, function () {
            var statusResponse, statusData, data, error_14;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 15, , 16]);
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 14];
                        return [4 /*yield*/, this.getRequest("".concat(this.apiUrl, "/v1/crawl/").concat(id), headers)];
                    case 2:
                        statusResponse = _a.sent();
                        if (!(statusResponse.status === 200)) return [3 /*break*/, 12];
                        statusData = statusResponse.data;
                        if (!(statusData.status === "completed")) return [3 /*break*/, 8];
                        if (!("data" in statusData)) return [3 /*break*/, 6];
                        data = statusData.data;
                        _a.label = 3;
                    case 3:
                        if (!(typeof statusData === 'object' && 'next' in statusData)) return [3 /*break*/, 5];
                        if (data.length === 0) {
                            return [3 /*break*/, 5];
                        }
                        return [4 /*yield*/, this.getRequest(statusData.next, headers)];
                    case 4:
                        statusResponse = _a.sent();
                        statusData = statusResponse.data;
                        data = data.concat(statusData.data);
                        return [3 /*break*/, 3];
                    case 5:
                        statusData.data = data;
                        return [2 /*return*/, statusData];
                    case 6: throw new FirecrawlError("Crawl job completed but no data was returned", 500);
                    case 7: return [3 /*break*/, 11];
                    case 8:
                        if (!["active", "paused", "pending", "queued", "waiting", "scraping"].includes(statusData.status)) return [3 /*break*/, 10];
                        checkInterval = Math.max(checkInterval, 2);
                        return [4 /*yield*/, new Promise(function (resolve) {
                                return setTimeout(resolve, checkInterval * 1000);
                            })];
                    case 9:
                        _a.sent();
                        return [3 /*break*/, 11];
                    case 10: throw new FirecrawlError("Crawl job failed or was stopped. Status: ".concat(statusData.status), 500);
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        this.handleError(statusResponse, "check crawl status");
                        _a.label = 13;
                    case 13: return [3 /*break*/, 1];
                    case 14: return [3 /*break*/, 16];
                    case 15:
                        error_14 = _a.sent();
                        throw new FirecrawlError(error_14, 500);
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Handles errors from API responses.
     * @param {AxiosResponse} response - The response from the API.
     * @param {string} action - The action being performed when the error occurred.
     */
    FirecrawlApp.prototype.handleError = function (response, action) {
        if ([402, 408, 409, 500].includes(response.status)) {
            var errorMessage = response.data.error || "Unknown error occurred";
            throw new FirecrawlError("Failed to ".concat(action, ". Status code: ").concat(response.status, ". Error: ").concat(errorMessage), response.status);
        }
        else {
            throw new FirecrawlError("Unexpected error occurred while trying to ".concat(action, ". Status code: ").concat(response.status), response.status);
        }
    };
    return FirecrawlApp;
}());
exports.default = FirecrawlApp;
var CrawlWatcher = /** @class */ (function (_super) {
    __extends(CrawlWatcher, _super);
    function CrawlWatcher(id, app) {
        var _this = _super.call(this) || this;
        _this.id = id;
        _this.ws = new isows_1.WebSocket("".concat(app.apiUrl, "/v1/crawl/").concat(id), app.apiKey);
        _this.status = "scraping";
        _this.data = [];
        var messageHandler = function (msg) {
            var _a;
            var _b;
            if (msg.type === "done") {
                _this.status = "completed";
                _this.dispatchTypedEvent("done", new CustomEvent("done", {
                    detail: {
                        status: _this.status,
                        data: _this.data,
                        id: _this.id,
                    },
                }));
            }
            else if (msg.type === "error") {
                _this.status = "failed";
                _this.dispatchTypedEvent("error", new CustomEvent("error", {
                    detail: {
                        status: _this.status,
                        data: _this.data,
                        error: msg.error,
                        id: _this.id,
                    },
                }));
            }
            else if (msg.type === "catchup") {
                _this.status = msg.data.status;
                (_a = _this.data).push.apply(_a, ((_b = msg.data.data) !== null && _b !== void 0 ? _b : []));
                for (var _i = 0, _c = _this.data; _i < _c.length; _i++) {
                    var doc = _c[_i];
                    _this.dispatchTypedEvent("document", new CustomEvent("document", {
                        detail: __assign(__assign({}, doc), { id: _this.id }),
                    }));
                }
            }
            else if (msg.type === "document") {
                _this.dispatchTypedEvent("document", new CustomEvent("document", {
                    detail: __assign(__assign({}, msg.data), { id: _this.id }),
                }));
            }
        };
        _this.ws.onmessage = (function (ev) {
            if (typeof ev.data !== "string") {
                _this.ws.close();
                return;
            }
            try {
                var msg = JSON.parse(ev.data);
                messageHandler(msg);
            }
            catch (error) {
                console.error("Error on message", error);
            }
        }).bind(_this);
        _this.ws.onclose = (function (ev) {
            try {
                var msg = JSON.parse(ev.reason);
                messageHandler(msg);
            }
            catch (error) {
                console.error("Error on close", error);
            }
        }).bind(_this);
        _this.ws.onerror = (function (_) {
            _this.status = "failed";
            _this.dispatchTypedEvent("error", new CustomEvent("error", {
                detail: {
                    status: _this.status,
                    data: _this.data,
                    error: "WebSocket error",
                    id: _this.id,
                },
            }));
        }).bind(_this);
        return _this;
    }
    CrawlWatcher.prototype.close = function () {
        this.ws.close();
    };
    return CrawlWatcher;
}(typescript_event_target_1.TypedEventTarget));
exports.CrawlWatcher = CrawlWatcher;
